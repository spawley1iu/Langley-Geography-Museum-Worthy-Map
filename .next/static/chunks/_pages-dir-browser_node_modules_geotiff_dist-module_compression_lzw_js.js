"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_pages-dir-browser_node_modules_geotiff_dist-module_compression_lzw_js"],{

/***/ "(pages-dir-browser)/./node_modules/geotiff/dist-module/compression/lzw.js":
/*!*************************************************************!*\
  !*** ./node_modules/geotiff/dist-module/compression/lzw.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ LZWDecoder)\n/* harmony export */ });\n/* harmony import */ var _basedecoder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./basedecoder.js */ \"(pages-dir-browser)/./node_modules/geotiff/dist-module/compression/basedecoder.js\");\n\n\nconst MIN_BITS = 9;\nconst CLEAR_CODE = 256; // clear code\nconst EOI_CODE = 257; // end of information\nconst MAX_BYTELENGTH = 12;\n\nfunction getByte(array, position, length) {\n  const d = position % 8;\n  const a = Math.floor(position / 8);\n  const de = 8 - d;\n  const ef = (position + length) - ((a + 1) * 8);\n  let fg = (8 * (a + 2)) - (position + length);\n  const dg = ((a + 2) * 8) - position;\n  fg = Math.max(0, fg);\n  if (a >= array.length) {\n    console.warn('ran off the end of the buffer before finding EOI_CODE (end on input code)');\n    return EOI_CODE;\n  }\n  let chunk1 = array[a] & ((2 ** (8 - d)) - 1);\n  chunk1 <<= (length - de);\n  let chunks = chunk1;\n  if (a + 1 < array.length) {\n    let chunk2 = array[a + 1] >>> fg;\n    chunk2 <<= Math.max(0, (length - dg));\n    chunks += chunk2;\n  }\n  if (ef > 8 && a + 2 < array.length) {\n    const hi = ((a + 3) * 8) - (position + length);\n    const chunk3 = array[a + 2] >>> hi;\n    chunks += chunk3;\n  }\n  return chunks;\n}\n\nfunction appendReversed(dest, source) {\n  for (let i = source.length - 1; i >= 0; i--) {\n    dest.push(source[i]);\n  }\n  return dest;\n}\n\nfunction decompress(input) {\n  const dictionaryIndex = new Uint16Array(4093);\n  const dictionaryChar = new Uint8Array(4093);\n  for (let i = 0; i <= 257; i++) {\n    dictionaryIndex[i] = 4096;\n    dictionaryChar[i] = i;\n  }\n  let dictionaryLength = 258;\n  let byteLength = MIN_BITS;\n  let position = 0;\n\n  function initDictionary() {\n    dictionaryLength = 258;\n    byteLength = MIN_BITS;\n  }\n  function getNext(array) {\n    const byte = getByte(array, position, byteLength);\n    position += byteLength;\n    return byte;\n  }\n  function addToDictionary(i, c) {\n    dictionaryChar[dictionaryLength] = c;\n    dictionaryIndex[dictionaryLength] = i;\n    dictionaryLength++;\n    return dictionaryLength - 1;\n  }\n  function getDictionaryReversed(n) {\n    const rev = [];\n    for (let i = n; i !== 4096; i = dictionaryIndex[i]) {\n      rev.push(dictionaryChar[i]);\n    }\n    return rev;\n  }\n\n  const result = [];\n  initDictionary();\n  const array = new Uint8Array(input);\n  let code = getNext(array);\n  let oldCode;\n  while (code !== EOI_CODE) {\n    if (code === CLEAR_CODE) {\n      initDictionary();\n      code = getNext(array);\n      while (code === CLEAR_CODE) {\n        code = getNext(array);\n      }\n\n      if (code === EOI_CODE) {\n        break;\n      } else if (code > CLEAR_CODE) {\n        throw new Error(`corrupted code at scanline ${code}`);\n      } else {\n        const val = getDictionaryReversed(code);\n        appendReversed(result, val);\n        oldCode = code;\n      }\n    } else if (code < dictionaryLength) {\n      const val = getDictionaryReversed(code);\n      appendReversed(result, val);\n      addToDictionary(oldCode, val[val.length - 1]);\n      oldCode = code;\n    } else {\n      const oldVal = getDictionaryReversed(oldCode);\n      if (!oldVal) {\n        throw new Error(`Bogus entry. Not in dictionary, ${oldCode} / ${dictionaryLength}, position: ${position}`);\n      }\n      appendReversed(result, oldVal);\n      result.push(oldVal[oldVal.length - 1]);\n      addToDictionary(oldCode, oldVal[oldVal.length - 1]);\n      oldCode = code;\n    }\n\n    if (dictionaryLength + 1 >= (2 ** byteLength)) {\n      if (byteLength === MAX_BYTELENGTH) {\n        oldCode = undefined;\n      } else {\n        byteLength++;\n      }\n    }\n    code = getNext(array);\n  }\n  return new Uint8Array(result);\n}\n\nclass LZWDecoder extends _basedecoder_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n  decodeBlock(buffer) {\n    return decompress(buffer, false).buffer;\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9nZW90aWZmL2Rpc3QtbW9kdWxlL2NvbXByZXNzaW9uL2x6dy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUEyQzs7QUFFM0M7QUFDQSx3QkFBd0I7QUFDeEIsc0JBQXNCO0FBQ3RCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtDQUFrQyxRQUFRO0FBQzFDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixVQUFVO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1Isc0RBQXNELEtBQUs7QUFDM0QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSwyREFBMkQsU0FBUyxJQUFJLGlCQUFpQixjQUFjLFNBQVM7QUFDaEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFZSx5QkFBeUIsdURBQVc7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zdGV3YXJ0cGF3bGV5L0xpYnJhcnkvQ2xvdWRTdG9yYWdlL09uZURyaXZlLUtDVENTL0dlb2dyYXBoeS9JbnRlcmFjdGl2ZSBNYXAvTXVzZXVtIE1hcC9MYW5nbGV5LUdlb2dyYXBoeS1NdXNldW0tV29ydGh5LU1hcC9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9jb21wcmVzc2lvbi9sencuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEJhc2VEZWNvZGVyIGZyb20gJy4vYmFzZWRlY29kZXIuanMnO1xuXG5jb25zdCBNSU5fQklUUyA9IDk7XG5jb25zdCBDTEVBUl9DT0RFID0gMjU2OyAvLyBjbGVhciBjb2RlXG5jb25zdCBFT0lfQ09ERSA9IDI1NzsgLy8gZW5kIG9mIGluZm9ybWF0aW9uXG5jb25zdCBNQVhfQllURUxFTkdUSCA9IDEyO1xuXG5mdW5jdGlvbiBnZXRCeXRlKGFycmF5LCBwb3NpdGlvbiwgbGVuZ3RoKSB7XG4gIGNvbnN0IGQgPSBwb3NpdGlvbiAlIDg7XG4gIGNvbnN0IGEgPSBNYXRoLmZsb29yKHBvc2l0aW9uIC8gOCk7XG4gIGNvbnN0IGRlID0gOCAtIGQ7XG4gIGNvbnN0IGVmID0gKHBvc2l0aW9uICsgbGVuZ3RoKSAtICgoYSArIDEpICogOCk7XG4gIGxldCBmZyA9ICg4ICogKGEgKyAyKSkgLSAocG9zaXRpb24gKyBsZW5ndGgpO1xuICBjb25zdCBkZyA9ICgoYSArIDIpICogOCkgLSBwb3NpdGlvbjtcbiAgZmcgPSBNYXRoLm1heCgwLCBmZyk7XG4gIGlmIChhID49IGFycmF5Lmxlbmd0aCkge1xuICAgIGNvbnNvbGUud2FybigncmFuIG9mZiB0aGUgZW5kIG9mIHRoZSBidWZmZXIgYmVmb3JlIGZpbmRpbmcgRU9JX0NPREUgKGVuZCBvbiBpbnB1dCBjb2RlKScpO1xuICAgIHJldHVybiBFT0lfQ09ERTtcbiAgfVxuICBsZXQgY2h1bmsxID0gYXJyYXlbYV0gJiAoKDIgKiogKDggLSBkKSkgLSAxKTtcbiAgY2h1bmsxIDw8PSAobGVuZ3RoIC0gZGUpO1xuICBsZXQgY2h1bmtzID0gY2h1bmsxO1xuICBpZiAoYSArIDEgPCBhcnJheS5sZW5ndGgpIHtcbiAgICBsZXQgY2h1bmsyID0gYXJyYXlbYSArIDFdID4+PiBmZztcbiAgICBjaHVuazIgPDw9IE1hdGgubWF4KDAsIChsZW5ndGggLSBkZykpO1xuICAgIGNodW5rcyArPSBjaHVuazI7XG4gIH1cbiAgaWYgKGVmID4gOCAmJiBhICsgMiA8IGFycmF5Lmxlbmd0aCkge1xuICAgIGNvbnN0IGhpID0gKChhICsgMykgKiA4KSAtIChwb3NpdGlvbiArIGxlbmd0aCk7XG4gICAgY29uc3QgY2h1bmszID0gYXJyYXlbYSArIDJdID4+PiBoaTtcbiAgICBjaHVua3MgKz0gY2h1bmszO1xuICB9XG4gIHJldHVybiBjaHVua3M7XG59XG5cbmZ1bmN0aW9uIGFwcGVuZFJldmVyc2VkKGRlc3QsIHNvdXJjZSkge1xuICBmb3IgKGxldCBpID0gc291cmNlLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgZGVzdC5wdXNoKHNvdXJjZVtpXSk7XG4gIH1cbiAgcmV0dXJuIGRlc3Q7XG59XG5cbmZ1bmN0aW9uIGRlY29tcHJlc3MoaW5wdXQpIHtcbiAgY29uc3QgZGljdGlvbmFyeUluZGV4ID0gbmV3IFVpbnQxNkFycmF5KDQwOTMpO1xuICBjb25zdCBkaWN0aW9uYXJ5Q2hhciA9IG5ldyBVaW50OEFycmF5KDQwOTMpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8PSAyNTc7IGkrKykge1xuICAgIGRpY3Rpb25hcnlJbmRleFtpXSA9IDQwOTY7XG4gICAgZGljdGlvbmFyeUNoYXJbaV0gPSBpO1xuICB9XG4gIGxldCBkaWN0aW9uYXJ5TGVuZ3RoID0gMjU4O1xuICBsZXQgYnl0ZUxlbmd0aCA9IE1JTl9CSVRTO1xuICBsZXQgcG9zaXRpb24gPSAwO1xuXG4gIGZ1bmN0aW9uIGluaXREaWN0aW9uYXJ5KCkge1xuICAgIGRpY3Rpb25hcnlMZW5ndGggPSAyNTg7XG4gICAgYnl0ZUxlbmd0aCA9IE1JTl9CSVRTO1xuICB9XG4gIGZ1bmN0aW9uIGdldE5leHQoYXJyYXkpIHtcbiAgICBjb25zdCBieXRlID0gZ2V0Qnl0ZShhcnJheSwgcG9zaXRpb24sIGJ5dGVMZW5ndGgpO1xuICAgIHBvc2l0aW9uICs9IGJ5dGVMZW5ndGg7XG4gICAgcmV0dXJuIGJ5dGU7XG4gIH1cbiAgZnVuY3Rpb24gYWRkVG9EaWN0aW9uYXJ5KGksIGMpIHtcbiAgICBkaWN0aW9uYXJ5Q2hhcltkaWN0aW9uYXJ5TGVuZ3RoXSA9IGM7XG4gICAgZGljdGlvbmFyeUluZGV4W2RpY3Rpb25hcnlMZW5ndGhdID0gaTtcbiAgICBkaWN0aW9uYXJ5TGVuZ3RoKys7XG4gICAgcmV0dXJuIGRpY3Rpb25hcnlMZW5ndGggLSAxO1xuICB9XG4gIGZ1bmN0aW9uIGdldERpY3Rpb25hcnlSZXZlcnNlZChuKSB7XG4gICAgY29uc3QgcmV2ID0gW107XG4gICAgZm9yIChsZXQgaSA9IG47IGkgIT09IDQwOTY7IGkgPSBkaWN0aW9uYXJ5SW5kZXhbaV0pIHtcbiAgICAgIHJldi5wdXNoKGRpY3Rpb25hcnlDaGFyW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldjtcbiAgfVxuXG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBpbml0RGljdGlvbmFyeSgpO1xuICBjb25zdCBhcnJheSA9IG5ldyBVaW50OEFycmF5KGlucHV0KTtcbiAgbGV0IGNvZGUgPSBnZXROZXh0KGFycmF5KTtcbiAgbGV0IG9sZENvZGU7XG4gIHdoaWxlIChjb2RlICE9PSBFT0lfQ09ERSkge1xuICAgIGlmIChjb2RlID09PSBDTEVBUl9DT0RFKSB7XG4gICAgICBpbml0RGljdGlvbmFyeSgpO1xuICAgICAgY29kZSA9IGdldE5leHQoYXJyYXkpO1xuICAgICAgd2hpbGUgKGNvZGUgPT09IENMRUFSX0NPREUpIHtcbiAgICAgICAgY29kZSA9IGdldE5leHQoYXJyYXkpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY29kZSA9PT0gRU9JX0NPREUpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2UgaWYgKGNvZGUgPiBDTEVBUl9DT0RFKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgY29ycnVwdGVkIGNvZGUgYXQgc2NhbmxpbmUgJHtjb2RlfWApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgdmFsID0gZ2V0RGljdGlvbmFyeVJldmVyc2VkKGNvZGUpO1xuICAgICAgICBhcHBlbmRSZXZlcnNlZChyZXN1bHQsIHZhbCk7XG4gICAgICAgIG9sZENvZGUgPSBjb2RlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY29kZSA8IGRpY3Rpb25hcnlMZW5ndGgpIHtcbiAgICAgIGNvbnN0IHZhbCA9IGdldERpY3Rpb25hcnlSZXZlcnNlZChjb2RlKTtcbiAgICAgIGFwcGVuZFJldmVyc2VkKHJlc3VsdCwgdmFsKTtcbiAgICAgIGFkZFRvRGljdGlvbmFyeShvbGRDb2RlLCB2YWxbdmFsLmxlbmd0aCAtIDFdKTtcbiAgICAgIG9sZENvZGUgPSBjb2RlO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBvbGRWYWwgPSBnZXREaWN0aW9uYXJ5UmV2ZXJzZWQob2xkQ29kZSk7XG4gICAgICBpZiAoIW9sZFZhbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEJvZ3VzIGVudHJ5LiBOb3QgaW4gZGljdGlvbmFyeSwgJHtvbGRDb2RlfSAvICR7ZGljdGlvbmFyeUxlbmd0aH0sIHBvc2l0aW9uOiAke3Bvc2l0aW9ufWApO1xuICAgICAgfVxuICAgICAgYXBwZW5kUmV2ZXJzZWQocmVzdWx0LCBvbGRWYWwpO1xuICAgICAgcmVzdWx0LnB1c2gob2xkVmFsW29sZFZhbC5sZW5ndGggLSAxXSk7XG4gICAgICBhZGRUb0RpY3Rpb25hcnkob2xkQ29kZSwgb2xkVmFsW29sZFZhbC5sZW5ndGggLSAxXSk7XG4gICAgICBvbGRDb2RlID0gY29kZTtcbiAgICB9XG5cbiAgICBpZiAoZGljdGlvbmFyeUxlbmd0aCArIDEgPj0gKDIgKiogYnl0ZUxlbmd0aCkpIHtcbiAgICAgIGlmIChieXRlTGVuZ3RoID09PSBNQVhfQllURUxFTkdUSCkge1xuICAgICAgICBvbGRDb2RlID0gdW5kZWZpbmVkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnl0ZUxlbmd0aCsrO1xuICAgICAgfVxuICAgIH1cbiAgICBjb2RlID0gZ2V0TmV4dChhcnJheSk7XG4gIH1cbiAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHJlc3VsdCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExaV0RlY29kZXIgZXh0ZW5kcyBCYXNlRGVjb2RlciB7XG4gIGRlY29kZUJsb2NrKGJ1ZmZlcikge1xuICAgIHJldHVybiBkZWNvbXByZXNzKGJ1ZmZlciwgZmFsc2UpLmJ1ZmZlcjtcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/geotiff/dist-module/compression/lzw.js\n"));

/***/ })

}]);